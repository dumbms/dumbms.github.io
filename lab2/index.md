# 6.828 Lab 2: Memory Management


[å®éªŒåœ°å€ Lab 2: Memory Management ](https://pdos.csail.mit.edu/6.828/2018/labs/lab2/)



## 0 Introduction

åœ¨è¿™ä¸ªlabä¸­ï¼Œå°†å®ç°æ“ä½œç³»ç»Ÿçš„å†…å­˜ç®¡ç†éƒ¨åˆ†ï¼š

**ç¬¬ä¸€ä¸ªéƒ¨åˆ†**æ˜¯å®ç°ä¸€ä¸ªå†…æ ¸çš„ç‰©ç†å†…å­˜åˆ†é…å™¨ï¼Œè¿™æ ·å†…æ ¸å°±å¯ä»¥åˆ†é…å†…å­˜ï¼Œç„¶åé‡Šæ”¾å†…å­˜ã€‚è¯¥åˆ†é…å™¨å°†ä»¥4096å­—èŠ‚(ç§°ä¸ºé¡µ)ä¸ºå•ä½è¿›è¡Œæ“ä½œã€‚å®ç°è¿™ä¸ªç‰©ç†å†…å­˜åˆ†é…å™¨éœ€è¦ç»´æŠ¤ä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œä»¥è®°å½•å“ªäº›ç‰©ç†é¡µæ˜¯ç©ºé—²çš„ï¼Œå“ªäº›é¡µæ˜¯åˆ†é…çš„ï¼Œä»¥åŠå…±äº«æ¯ä¸ªåˆ†é…é¡µçš„è¿›ç¨‹æ•°é‡ã€‚å¹¶ä¸”éœ€è¦ç¼–å†™åˆ†é…å’Œé‡Šæ”¾å†…å­˜é¡µçš„ç›¸å…³ä»£ç ã€‚

å†…å­˜ç®¡ç†çš„**ç¬¬äºŒä¸ªéƒ¨åˆ†**æ˜¯è™šæ‹Ÿå†…å­˜ï¼Œå®ƒå°†å†…æ ¸å’Œç”¨æˆ·ä½¿ç”¨çš„è™šæ‹Ÿåœ°å€æ˜ å°„åˆ°ç‰©ç†å†…å­˜ä¸­çš„åœ°å€ã€‚å½“æŒ‡ä»¤ä½¿ç”¨åˆ°å†…å­˜æ—¶ï¼Œx86ç¡¬ä»¶çš„å†…å­˜ç®¡ç†å•å…ƒ(MMU)é€šè¿‡æŸ¥è¯¢ä¸€ç»„é¡µè¡¨æ¥æ‰§è¡Œæ˜ å°„ã€‚

---



## 1 Physical Page Management

æ“ä½œç³»ç»Ÿå¿…é¡»`keep track of`ç‰©ç† RAM çš„å“ªäº›éƒ¨åˆ†æ˜¯ç©ºé—²çš„ï¼Œå“ªäº›éƒ¨åˆ†å½“å‰æ­£åœ¨ä½¿ç”¨ã€‚JOS é€šè¿‡é¡µé¢ç²’åº¦ç®¡ç† PC çš„ç‰©ç†å†…å­˜ï¼Œè¿™æ ·å®ƒå°±å¯ä»¥ä½¿ç”¨ MMU æ¥æ˜ å°„å’Œä¿æŠ¤åˆ†é…çš„æ¯å—å†…å­˜ã€‚

<div align=center>{{< image src="assets/JOS.png" caption="JOSåˆå§‹åŒ–å†…å­˜åˆ†å¸ƒ" >}}</div>

#### Exercise 1

åœ¨`kern/pmap.c`, éœ€è¦å®ç°ä»¥ä¸‹å‡ ä¸ªå‡½æ•°

```c
boot_alloc()
mem_init() (only up to the call to check_page_free_list(1))
page_init()
page_alloc()
page_free()
```

##### boot_alloc

è¯¥å‡½æ•°å®ç°å†…æ ¸åˆå§‹åŒ–çš„è¿‡ç¨‹ä¸­ï¼Œç‰©ç†å†…å­˜çš„åˆ†é…ã€‚

`end`å˜é‡æ˜¯å®šä¹‰åœ¨`kernel.ld`æ–‡ä»¶é‡Œé¢çš„ï¼ŒæŒ‡å‘äº†å†…æ ¸åœ°å€çš„æœ«ä½ã€‚

**æ³¨æ„**è¿™é‡Œè¦åˆ°çš„åœ°å€æ˜¯è™šæ‹Ÿåœ°å€ï¼Œä¸æ˜¯ç‰©ç†åœ°å€ã€‚

```c
static void *
boot_alloc(uint32_t n)
{
	static char *nextfree;	// virtual address of next byte of free memory
	char *result;

	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
	}

	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
// LAB 2: Your code here.
	if (n == 0) {
		return nextfree;
	} 
	result = nextfree;
	nextfree = ROUNDUP(nextfree + n, PGSIZE);	

	if ((uint32_t)(nextfree + n - KERNBASE) > npages * PGSIZE) {
		panic("out of memory !");
	}
	return result;
}
```

ä¹‹å‰åšè¿™ä¸ªexercieseçš„æ—¶å€™æœ‰ä¸ªç–‘æƒ‘ğŸ¤”ï¼šboot_alloc ä»£ç å®ç°æ˜¯åˆ†é…äº†å†…æ ¸end ç»“æŸåçš„è™šæ‹Ÿåœ°å€ï¼Œä½†è¦æ±‚åˆ†é…çš„ç¡®æ˜¯ç‰©ç†åœ°å€ã€‚

ç­”æ¡ˆæ˜¯å› ä¸ºï¼Œåœ¨è¿›å…¥å†…æ ¸çš„æ—¶å€™å·²ç»å°†CR3è®¾ç½®ä¸ºæ‰‹å†™é¡µè¡¨çš„åœ°å€å¯å‚è€ƒLAB1 çš„æ€»ç»“ï¼Œè¿™ä¸ªé¡µè¡¨ä¸­å­˜æ”¾ç€[0, 4MB] å’Œ [KERNBASE, KERNBASE+4MB) åˆ°ç‰©ç†åœ°å€çš„ [0, 4MB) çš„æ˜ å°„ï¼Œè¿™æ ·åˆå§‹åŒ–å†…æ ¸åˆ†é…ç‰©ç†å†…å­˜çš„æ—¶å€™ï¼Œå°±å¯ä»¥ç›´æ¥ä½¿ç”¨è™šæ‹Ÿåœ°å€æ¥åˆ†é…ï¼Œmmuç¡¬ä»¶åœ¨èƒŒåä¼šå¸®æˆ‘ä»¬è‡ªåŠ¨è½¬ä¸ºç‰©ç†åœ°å€ï¼Œcoolï¼ä¹Ÿæ­£å› ä¸ºæœ‰äº†mmuç¡¬ä»¶è¿™ç§åŠŸèƒ½ï¼Œcè¯­è¨€æ“ä½œçš„åœ°å€å‡ä¸ºè™šæ‹Ÿåœ°å€ã€‚

---

##### mem_init

<div align=center>{{< image src="assets/ç‰©ç†åœ°å€åˆ†å¸ƒ.jpg" caption="JOSåˆå§‹åŒ–ç‰©ç†å†…å­˜åˆ†å¸ƒ" >}}</div>

åœ¨ç‰©ç†å†…å­˜åœ°å€ï¼Œåˆ†é…äº†ä¸€ä¸ª pages æ•°ç»„ï¼Œè¯¥æ•°ç»„çš„å…ƒç´ ä¸ºstruct PageInfoï¼ŒæŠ½è±¡å‡ºpagesæ•°ç»„æ¥æè¿°ç‰©ç†å†…å­˜çš„ä½¿ç”¨æƒ…å†µï¼ŒPageInfo ä¸­æœ‰ä¸¤ä¸ªå˜é‡ï¼Œä¸€ä¸ªæ˜¯æŒ‡å‘ä¸‹ä¸€ä¸ªç©ºé—²é¡µé¢çš„æŒ‡é’ˆï¼Œä¸€ä¸ªæ˜¯è¡¨ç¤ºè¯¥ç‰©ç†åœ°å€é¡µé¢è¢«ä¸åŒçš„è™šæ‹Ÿåœ°å€æ˜ å°„çš„æ•°é‡(å†™æ—¶å¤åˆ¶)ã€‚

Is it NOT the physical page itself, but there is a one-to-one correspondence between physical pages and struct PageInfo's.

```c
struct PageInfo {
	// Next page on the free list.
	struct PageInfo *pp_link;

	// pp_ref is the count of pointers (usually in page table entries)
	// to this page, for pages allocated using page_alloc.
	// Pages allocated at boot time using pmap.c's
	// boot_alloc do not have valid reference count fields.

	uint16_t pp_ref;
};
```

npages æ˜¯åœ¨ i386_detect_memory ä¸­ æ£€æµ‹å‡ºçœŸå®ç‰©ç†é¡µçš„æ•°é‡ã€‚

```c
void
mem_init(void)
{	
	...
	// Permissions: kernel R, user R
	kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;

	//////////////////////////////////////////////////////////////////////
	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.  Use memset
	// to initialize all fields of each struct PageInfo to 0.
// Your code goes here:
	pages = (struct PageInfo *) boot_alloc(npages*sizeof(struct PageInfo)); 
// è¿™é‡Œmemset ä½¿ç”¨çš„pagesæ˜¯è™šæ‹Ÿåœ°å€ï¼ŒçŒœçŒœçœ‹ä¸ºä»€ä¹ˆå¯ä»¥ä½¿ç”¨è™šæ‹Ÿåœ°å€æ¥åˆå§‹åŒ–å†…å­˜ğŸ˜€
	memset(pages, 0, npages*sizeof(struct PageInfo));
	...
}
```

---

##### page_init

è¯¥å‡½æ•°æ¥é€šè¿‡pages çš„æ¯ä¸ªPageInfoä¸çœŸå®çš„ç‰©ç†åœ°å€åˆ¶é€ è”ç³»ï¼Œä»è€Œæ¥è¿½è¸ªçœŸå®ç‰©ç†é¡µçš„ä½¿ç”¨æƒ…å†µã€‚

åœ¨pmap.hæœ‰ä¸¤ä¸ªé‡è¦çš„å®PADDRã€KADDRéœ€è¦äº†è§£ä»¥ä¸‹ï¼Œç®€å•æ¥è¯´

PADDRï¼šå°†é«˜ä½è™šæ‹Ÿåœ°å€è½¬ä¸ºä½ä½çš„ç‰©ç†åœ°å€ã€‚

KADDRï¼šå°†ä½ä½ç‰©ç†åœ°å€è½¬ä¸ºé«˜ä½çš„è™šæ‹Ÿåœ°å€ã€‚

```c
/* This macro takes a kernel virtual address -- an address that points above
 * KERNBASE, where the machine's maximum 256MB of physical memory is mapped --
 * and returns the corresponding physical address.  It panics if you pass it a
 * non-kernel virtual address.
 */
#define PADDR(kva) _paddr(__FILE__, __LINE__, kva)

static inline physaddr_t
_paddr(const char *file, int line, void *kva)
{
	if ((uint32_t)kva < KERNBASE)
		_panic(file, line, "PADDR called with invalid kva %08lx", kva);
	return (physaddr_t)kva - KERNBASE;
}

/* This macro takes a physical address and returns the corresponding kernel
 * virtual address.  It panics if you pass an invalid physical address. */
#define KADDR(pa) _kaddr(__FILE__, __LINE__, pa)

static inline void*
_kaddr(const char *file, int line, physaddr_t pa)
{
	if (PGNUM(pa) >= npages)
		_panic(file, line, "KADDR called with invalid pa %08lx", pa);
	return (void *)(pa + KERNBASE);
}
```

æ ¹æ®ç»™å®šçš„æç¤ºå¾ˆå®¹æ˜“æ¨¡ä»¿å†™å‡ºç›¸åº”çš„ä»£ç ã€‚

```c
void
page_init(void)
{
	...
	size_t i;
	for (i = 0; i < npages; i++) {
		if (i == 0) {
			pages[i].pp_ref = 1;
			pages[i].pp_link = NULL;
		}
		else if (i >= 1 && i < npages_basemem) {
			pages[i].pp_ref = 0;
			pages[i].pp_link = page_free_list;
			page_free_list = &pages[i];
		}
		else if (i >= (IOPHYSMEM / PGSIZE) && i < (EXTPHYSMEM / PGSIZE)) {
			pages[i].pp_ref = 1;
			pages[i].pp_link = NULL;
		}
// å°†[EXTPHYSMEM, å†…æ ¸å½“å‰æœ€åä¸€é¡µçš„åœ°å€ï¼‰æ ‡è®°ä¸ºå·²è¢«å¼•ç”¨ï¼Œé˜²æ­¢è§¦ç¢°å†…æ ¸ä»£ç ã€‚
		else if (i >= (EXTPHYSMEM / PGSIZE) && i < (PADDR(boot_alloc(0)) / PGSIZE)) {
			pages[i].pp_ref = 1;
		}
// è¿™é‡Œè¦æ‹¿åˆ°å†…æ ¸ç¬¬ä¸€ä¸ªæœªä½¿ç”¨çš„åœ°å€ï¼Œä½¿ç”¨boot_alloc(0)å¾ˆå·§å¦™çš„æ‹¿åˆ°ã€‚ 
		else if (i >= (PADDR(boot_alloc(0)) / PGSIZE) && i < npages){
			pages[i].pp_ref = 0;
			pages[i].pp_link = page_free_list;
			page_free_list = &pages[i];
		}	
	}
}
```

---

##### page_alloc

è¿™ä¸ªæ˜¯çœŸå®çš„æœ€åº•å±‚çš„ç‰©ç†åˆ†é…å™¨ã€‚

é€šè¿‡æŸ¥çœ‹page_free_list ç‰©ç†é¡µç©ºé—²é¡µè¡¨æ¥çœ‹æ˜¯å¦æœ‰ç©ºé—²ä¹Ÿï¼Œæœ‰çš„è¯å°±ä»é“¾è¡¨ä¸­å–å‡ºä¸€ä¸ªå°±è¡Œã€‚é€šè¿‡ alloc_flags æ¥åˆ¤æ–­æ˜¯å¦éœ€è¦åˆå§‹åŒ–å†…å­˜ã€‚

```c
// Allocates a physical page.  If (alloc_flags & ALLOC_ZERO), fills the entire
// returned physical page with '\0' bytes.  Does NOT increment the reference
// count of the page - the caller must do these if necessary (either explicitly
// or via page_insert).
//
// Be sure to set the pp_link field of the allocated page to NULL so
// page_free can check for double-free bugs.
//
// Returns NULL if out of free memory.
//
// Hint: use page2kva and memset
struct PageInfo *
page_alloc(int alloc_flags)
{
// Fill this function in
	struct PageInfo *p;
	if (!page_free_list) 
		return NULL;
	p = page_free_list;
	page_free_list = page_free_list->pp_link;
	p->pp_link = NULL;

	if (alloc_flags & ALLOC_ZERO) {
// page2kvaå°† pagesæ•°ç»„ä¸­çš„è™šæ‹Ÿåœ°å€pè½¬ä¸º ç‰©ç†é¡µ + KERNBASE å¯¹åº”çš„è™šæ‹Ÿåœ°å€ï¼Œ
// ç„¶åç›´æ¥é€šè¿‡è™šæ‹Ÿåœ°å€åˆå§‹åŒ–è¿™å—ç‰©ç†é¡µé¢çš„å€¼ï¼Œmmuç¡¬ä»¶åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­åšäº†è‡ªåŠ¨ç¿»è¯‘ã€‚
		memset(page2kva(p), 0, PGSIZE);
	}
	return p;
}
```

##### page_free

è¯¥å‡½æ•°åšçš„æ˜¯é‡Šæ”¾é¡µé¢ã€‚

pp_ref ä¸ä¸º0è¯´æ˜è¯¥é¡µé¢æ­£åœ¨è¢«æŸè™šæ‹Ÿåœ°å€æ˜ å°„ï¼Œpp_linkä¸ä¸ºNULLï¼Œè¯´æ˜è¯¥é¡µé¢å·²ä¸å†ç©ºé—²é“¾è¡¨ä¸­ï¼Œä¹Ÿå°±æ˜¯è¯´æ­£åœ¨è¢«ä½¿ç”¨ã€‚

```c
// Return a page to the free list.
// (This function should only be called when pp->pp_ref reaches 0.)
void
page_free(struct PageInfo *pp)
{
	// Fill this function in
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.
	if (pp->pp_ref || pp->pp_link != NULL) {
		panic("This page has other mappings in use!");
	}
	pp->pp_link = page_free_list;
	page_free_list = pp;
}
```

å¯ä»¥é€šè¿‡ä¸¤ä¸ªtestã€‚

```c
check_page_free_list() succeeded!
check_page_alloc() succeeded!
kernel panic at kern/pmap.c:723: assertion failed: page_insert(kern_pgdir, pp1, 0x0, PTE_W) < 0
Welcome to the JOS kernel monitor!
Type 'help' for a list of commands.
K> 
```

å†™äº†é‚£ä¹ˆå¤šmake grade å‘ç°åªå¾—äº†20åˆ†ã€‚ã€‚



## 2 Virtual Memory

#### Exercise 2

é˜…è¯»æ‰‹å†Œ[80386 Programmer's Reference Manual](https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm)ç¬¬äº”ç« ã€ç¬¬å…­ç« ï¼Œäº†è§£é¡µé¢ç¿»è¯‘å’ŒåŸºäºé¡µé¢ä¿æŠ¤å¾—å†…å®¹ã€‚

#### Exercise 3

ç†Ÿæ‚‰qemuæ“ä½œã€‚

#### Exercise 4

##### pgdir_walk

[80386 Programmer's Reference Manual -- Section 5.2](https://pdos.csail.mit.edu/6.828/2018/readings/i386/s05_02.htm)

è¯¥å‡½æ•°ä¸º mmu ç¡¬ä»¶çš„æä¾›æœåŠ¡ï¼Œåªæœ‰é¡µè¡¨ä¸­å­˜æ”¾æœ‰è™šæ‹Ÿåœ°å€åˆ°ç‰©ç†åœ°å€çš„ç¿»è¯‘ï¼Œmmuæ‰èƒ½å·¥ä½œã€‚æŒ‰ç…§æç¤ºå¤§æ¦‚å¯ä»¥å¾—åˆ°ä»¥ä¸‹æ€è·¯ï¼š

1. è¯¥å‡½æ•°çš„ä½œç”¨æ˜¯å°†ç»™å®šçš„è™šæ‹Ÿåœ°å€å’ŒæŒ‡å‘é¡µç›®å½•pgdirçš„æŒ‡é’ˆï¼Œè¿”å›ä¸€ä¸ªæŒ‡å‘é¡µè¡¨é¡¹ï¼ˆPTE page table entryï¼‰çš„æŒ‡é’ˆã€‚PTE ä¸ PDE è¡¨ç¤ºæ˜¯ä¸€æ ·çš„ï¼Œåªæ˜¯åœ¨é¡¶çº§ç›®å½•ä¸äºŒçº§é¡µè¡¨åŒºåˆ†å¼€ã€‚

2. JOS æ˜¯äºŒçº§é¡µè¡¨ï¼Œå‚è€ƒä¸‹å›¾ã€‚CR3æŒ‡é’ˆæŒ‡å‘é¡µç›®å½•é¡¹ï¼Œç„¶åå°†ç»™å®šçš„è™šæ‹Ÿåœ°å€vaåˆ†æˆä¸‰ä¸ªéƒ¨åˆ†ï¼Œå–å‡ºDIRè¿™ä¸ªéƒ¨åˆ†å½“æˆç´¢å¼•ï¼Œåœ¨é¡µç›®å½•ä¸­æ‰¾åˆ°å¯¹åº”é¡µç›®å½•é¡¹ï¼Œå…¶å®å°±æ˜¯ä¸€ä¸ªPTEã€‚å¦‚ä½•å–å‡ºDIRå‘¢ï¼Œmmu.hä¸­æä¾›äº†ç›¸å…³çš„å®ã€‚

   <div align=center>{{< image src="https://pdos.csail.mit.edu/6.828/2018/readings/i386/fig5-9.gif" caption="JOS Page Translation" width="50%">}}</div>

   ```c
   // A linear address 'la' has a three-part structure as follows:
   //
   // +--------10------+-------10-------+---------12----------+
   // | Page Directory |   Page Table   | Offset within Page  |
   // |      Index     |      Index     |                     |
   // +----------------+----------------+---------------------+
   //  \--- PDX(la) --/ \--- PTX(la) --/ \---- PGOFF(la) ----/
   //  \---------- PGNUM(la) ----------/
   //
   // The PDX, PTX, PGOFF, and PGNUM macros decompose linear addresses as shown.
   // To construct a linear address la from PDX(la), PTX(la), and PGOFF(la),
   // use PGADDR(PDX(la), PTX(la), PGOFF(la)).
   
   // page number field of address
   #define PGNUM(la)	(((uintptr_t) (la)) >> PTXSHIFT)
   
   // page directory index 
   // åšè¿‡csappç¬¬ä¸€ç« çš„datalabåï¼Œå¯¹è¿™ç§äºŒè¿›åˆ¶è¡¨ç¤ºçš„è¿ç®—ä¸ä¼šæ„Ÿåˆ°å¾ˆé™Œç”Ÿã€‚ 
   // è¿™é‡Œåšçš„å°±æ˜¯å°†ç»™å®šçš„vaå³ç§»22ä½ï¼Œå¾—åˆ°é«˜10ä½ï¼Œå¹¶& 0x3FF,å³å°†é«˜22ä½å–0ï¼Œä½10ä½ä¿ç•™1ã€‚
   // å¾—åˆ°çº¯å‡€çš„é«˜10ä½ã€‚
   #define PDX(la)		((((uintptr_t) (la)) >> PDXSHIFT) & 0x3FF)
   
   // page table index
   #define PTX(la)		((((uintptr_t) (la)) >> PTXSHIFT) & 0x3FF)
   
   // offset in page
   #define PGOFF(la)	(((uintptr_t) (la)) & 0xFFF)
   
   ...
   #define PTXSHIFT	12		// offset of PTX in a linear address
   #define PDXSHIFT	22		// offset of PDX in a linear address
   ```

   

3. ä¸‹å›¾æ˜¯é¡µè¡¨é¡¹çš„å…·ä½“ç»†èŠ‚ï¼Œä¸€å…±32ä½ï¼Œä½12ä½ä¸ºæ ‡è¯†ç¬¦ã€‚ä»é¡µç›®å½•ä¸­æ‰¾åˆ°å¯¹åº”çš„PTEåï¼Œé€šè¿‡PTEä¸­çš„æœ€ä½ä½ï¼ˆPTE_Pï¼‰åˆ¤æ–­è¯¥é¡µç›®å½•é¡¹æ˜¯å¦æœ‰æ•ˆï¼Œå¦‚æœæœ‰æ•ˆï¼Œå–å‡ºé«˜20ä½ï¼Œå°†å…¶è½¬ä¸ºè™šæ‹Ÿåœ°å€æŒ‡é’ˆï¼Œè¿”å›å³å¾—åˆ°æ‰€éœ€ç­”æ¡ˆã€‚

   æ³¨æ„ï¼šPTEä¸­é«˜23ä½å­˜æ”¾çš„æ˜¯çœŸå®çš„ç‰©ç†åœ°å€ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨çš„æ˜¯è™šæ‹Ÿåœ°å€ã€‚

   <div align=center>{{< image src="https://pdos.csail.mit.edu/6.828/2018/readings/i386/fig5-10.gif" caption="Format of a Page Table Entry" width="50%">}}</div>

4. å¦‚æœ2ä¸­åœ¨é¡µç›®å½•è¡¨ä¸­æ‰¾åˆ°çš„PTEçš„æœ€ä½ä½Pä¸º0ï¼Œå³è¡¨ç¤ºè¯¥PTEæ— æ•ˆï¼Œè¿™æ—¶å€™å°±éœ€è¦æ–°åˆ†é…ä¸€ä¸ªé¡µé¢ï¼Œä½¿ç”¨ä¹‹å‰å†™è¿‡çš„å‡½æ•°page_allocåˆ†é…ä¸€ä¸ªé¡µé¢ï¼Œè¯¥å‡½æ•°è¿”å›çš„æ˜¯Struct PageInfoï¼Œåœ¨pmap.hä¸­æœ‰ä¸ªå‡½æ•°page2paå¯ä»¥å°†pageinfoè½¬ä¸ºç‰©ç†åœ°å€ï¼Œå› ä¸ºä¸Šé¢è®²äº†PTEä¸­å­˜æ”¾çš„æ˜¯çœŸå®çš„ç‰©ç†åœ°å€ï¼ˆä¸ºä»€ä¹ˆæ˜¯è¿™ä¹ˆåšçš„å‘¢ï¼Œå¯ä»¥æƒ³æƒ³mmuç¿»è¯‘çš„é€»è¾‘ï¼‰ï¼Œå°†ç‰©ç†åœ°å€æ”¾åˆ°2ä¸­æ‰¾åˆ°çš„PTEé«˜23ä½ä¸­ï¼Œå¹¶ç»™å®ƒä¸€äº›æ ‡å¿—ä½æƒé™ã€‚

5. æœ‰äº†ä¸Šé¢æ€è·¯ï¼Œå°±å¯ä»¥å†™å‡ºç›¸åº”ä»£ç ï¼š

```c
// Given 'pgdir', a pointer to a page directory, pgdir_walk returns
// a pointer to the page table entry (PTE) for linear address 'va'.
// This requires walking the two-level page table structure.
//
// The relevant page table page might not exist yet.
// If this is true, and create == false, then pgdir_walk returns NULL.
// Otherwise, pgdir_walk allocates a new page table page with page_alloc.
//    - If the allocation fails, pgdir_walk returns NULL.
//    - Otherwise, the new page's reference count is incremented,
//	the page is cleared,
//	and pgdir_walk returns a pointer into the new page table page.
//
// Hint 1: you can turn a PageInfo * into the physical address of the
// page it refers to with page2pa() from kern/pmap.h.
//
// Hint 2: the x86 MMU checks permission bits in both the page directory
// and the page table, so it's safe to leave permissions in the page
// directory more permissive than strictly necessary.
//
// Hint 3: look at inc/mmu.h for useful macros that manipulate page
// table and page directory entries.
pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
	// Fill this function in
	pde_t *pde;
	pte_t *pte;
	struct PageInfo * p;
	pde = &pgdir[PDX(va)];
	if (!(*pde & PTE_P)) {
		if (!create || (p = page_alloc(1)) ==  NULL) {
				return NULL;
		}
		p->pp_ref++;
		pte = (pte_t *)page2kva(p);
		*pde = page2pa(p) | PTE_P |PTE_U |PTE_W;
	} else {
		pte = KADDR(PTE_ADDR(*pde));
	}
	return &pte[PTX(va)];
}
```

pgdir_walk å¹¶æ²¡æœ‰å†™å…¥æ˜ å°„ï¼Œåªæ˜¯æ ¹æ®è™šæ‹Ÿåœ°å€vaæ¥æ‰¾åˆ°å¯¹åº”çš„PTEã€‚

##### boot_map_region

è¯¥å‡½æ•°æ˜¯åœ¨é¡µè¡¨ä¸­å¡«æ˜ å°„çš„éƒ¨åˆ†ï¼Œä»pgdir_walkä¸­è·å¾—è™šæ‹Ÿåœ°å€vaå¯¹åº”çš„PTEï¼Œç„¶åæŠŠç‰©ç†åœ°å€å¡«åˆ°è¿™é‡Œé¢ï¼Œå¹¶ç»™permæƒé™å°±è¡Œã€‚

```c
// Map [va, va+size) of virtual address space to physical [pa, pa+size)
// in the page table rooted at pgdir.  Size is a multiple of PGSIZE, and
// va and pa are both page-aligned.
// Use permission bits perm|PTE_P for the entries.
//
// This function is only intended to set up the ``static'' mappings
// above UTOP. As such, it should *not* change the pp_ref field on the
// mapped pages.
//
// Hint: the TA solution uses pgdir_walk
static void
boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
{
	// Fill this function in
	pte_t * pte;
// è™½ç„¶æç¤ºè¯´va å’Œ pa éƒ½æ˜¯é¡µå¯¹é½çš„ï¼Œä½†è¿˜æ˜¯å†å¯¹é½ä¸€ä¸‹ä¿é™©ï¼Œæ€•åé¢è‡ªå·±ç”¨çš„æ—¶å€™å¾€æ‰‹åŠ¨å¯¹é½ã€‚
	uintptr_t _va = ROUNDDOWN(va, PGSIZE);
	physaddr_t _pa = ROUNDDOWN(pa, PGSIZE);
	int n = size / PGSIZE;
	for (int i = 0; i < n; ++i) {
		if ((pte = pgdir_walk(pgdir, (void *)_va, 1)) == NULL) {
			return;
		}
		*pte = PTE_ADDR(_pa) | perm | PTE_P;
		_va += PGSIZE;
		_pa += PGSIZE;
	}
}
```

##### page_lookup

è¯¥å‡½æ•°çš„ä½œç”¨æ˜¯ï¼Œç»™å®šè™šæ‹Ÿåœ°å€vaï¼Œè½¬æ¢æˆå¯¹åº”çš„pageinfoï¼Œhint ç»™äº†ä¸€ä¸ªpa2page çš„è¾…åŠ©å‡½æ•°ï¼Œç„¶åæŠŠæ‰¾åˆ°çš„PTEå­˜è¿›ç»™å®šçš„pte_storeé‡Œé¢ã€‚è¿™ä¸ªå‡½æ•°è¿˜æ˜¯æ¯”è¾ƒå¥½å®ç°çš„ã€‚

```c
// Return the page mapped at virtual address 'va'.
// If pte_store is not zero, then we store in it the address
// of the pte for this page.  This is used by page_remove and
// can be used to verify page permissions for syscall arguments,
// but should not be used by most callers.
//
// Return NULL if there is no page mapped at va.
//
// Hint: the TA solution uses pgdir_walk and pa2page.
//
struct PageInfo *
page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
{
	// Fill this function in
	pte_t *pte;
	if ((pte = pgdir_walk(pgdir, va, 0)) == NULL) {
		return NULL;
	}
// åšçš„lab 5 æ‰¾äº†åŠå¤©bugï¼Œä¸‹é¢è¿™è¡Œã€‚ğŸ¤¯
	if (!(*pte & PTE_P))
		return NULL;
	physaddr_t ph = PTE_ADDR(*pte);
	if (pte_store) {
		// åŒæŒ‡é’ˆè§£å¼•ç”¨å­˜æŒ‡é’ˆ
		*pte_store = pte;
	}
	return pa2page(ph);
}
```

è¿™é‡Œæœ‰ä¸ªåœ¨lab 5å¡äº†å¾ˆä¹…çš„bugï¼Œpgdir_walkè¿”å›ä¸€ä¸ªæŒ‡å‘äºŒçº§é¡µè¡¨é¡¹PTEçš„æŒ‡é’ˆï¼Œå¦‚æœPTEçš„pte_pæ ‡å¿—ä½ä¸º0ï¼Œå°±è¯´æ˜è¿™ä¸ªPTEé¡µè¡¨é¡¹é‡Œé¢å­˜æ”¾çš„æ˜ å°„æ˜¯æ— æ•ˆçš„ï¼Œå°±ä¸èƒ½å–å…¶ä¸­çš„å€¼å­˜åˆ°pte_storeç»™ä¸Šå±‚å‡½æ•°ä½¿ç”¨ï¼Œä¸€ä¸ªæ— æ•ˆçš„ç‰©ç†é¡µå¯èƒ½ä¼šå¯¼è‡´æœªçŸ¥çš„é”™è¯¯ï¼Œå½“ç„¶åœ¨ä¸Šå±‚å‡½æ•°ä¹Ÿèƒ½æå‰å…ˆåˆ¤æ–­vaå¯¹åº”çš„PTEæ˜¯å¦æœ‰æ•ˆï¼Œä½†ä¸Šå±‚å‡½æ•°ä½¿ç”¨çš„æ—¶å€™å¹¶æ²¡æœ‰æƒ³åˆ°åˆ¤æ–­ã€‚ã€‚ã€‚å¯¼è‡´å¿ƒæ€çˆ†ç‚¸ğŸ¤¯ğŸ¤¯ï¼Œå¡åœ¨lab 5 shell å¡äº†å¿«ä¸€å‘¨ã€‚

æ”¶è·æ˜¯å¯¹é¡µè¡¨çš„å·¥ä½œåŸç†çš„ç†è§£æ›´åŠ æ·±å…¥ï¼Œç®€è€Œè¨€ä¹‹ï¼Œè¿›ç¨‹çš„è™šæ‹Ÿåœ°å€ç©ºé—´çš„å®ç°æ˜¯é é¡µè¡¨ï¼Œé¡µè¡¨å®ç°è™šæ‹ŸåŒ–çš„æ–¹å¼ï¼Œå°±æ˜¯åœ¨å…¶é¡µè¡¨é¡¹ä¸­å¡«å…¥ç‰©ç†åœ°å€å’Œå¯¹åº”çš„ä½æƒé™é¡¹ï¼Œç„¶åmmuç¡¬ä»¶ä¼šé€šè¿‡CR3å¯„å­˜å™¨å¯¹åº”çš„é¡µç›®å½•åœ°å€ï¼Œä¸åŒçš„æ“ä½œç³»ç»Ÿé¡µè¡¨åˆ†çº§ä¹Ÿæœ‰ä¸åŒï¼ŒJOSå®ç°çš„æ˜¯äºŒçº§é¡µè¡¨ï¼Œxv6å®ç°çš„æ˜¯ä¸‰çº§é¡µè¡¨ï¼ŒåŸç†éƒ½æ˜¯ä¸€æ ·çš„ã€‚ç‰©ç†é¡µè¡¨ä¹‹é—´çš„éš”ç¦»ä¹Ÿå®ç°äº†è¿›ç¨‹ä¹‹é—´çš„çœŸå®ç‰©ç†åœ°å€éš”ç¦»æ€§ã€‚

ç®€å•çœ‹çœ‹[MMUåŸç† - çŸ¥ä¹ (zhihu.com)](https://zhuanlan.zhihu.com/p/354142930)

##### page_remove

è¿™ä¸ªå‡½æ•°å°±æ›´ç®€å•äº†ï¼ŒæŒ‰ç…§æ³¨é‡Šå®ƒçš„ä½œç”¨æ˜¯å–æ¶ˆæ˜ å°„å¹¶ä¸”å°†pageinfoçš„å¼•ç”¨å‡å°‘ï¼Œä¸Šé¢è®²äº†è™šæ‹Ÿåœ°å€æ˜ å°„å®é™…ä¸Šæ˜¯å°†ç‰©ç†é¡µåœ°å€å­˜åœ¨PTEé¡µè¡¨é¡¹é‡Œï¼Œå–æ¶ˆæ˜ å°„å°±ç›´æ¥å°†é¡µè¡¨é¡¹è‡³0å°±å¥½äº†ã€‚

```c
// Unmaps the physical page at virtual address 'va'.
// If there is no physical page at that address, silently does nothing.
//
// Details:
//   - The ref count on the physical page should decrement.
//   - The physical page should be freed if the refcount reaches 0.
//   - The pg table entry corresponding to 'va' should be set to 0.
//     (if such a PTE exists)
//   - The TLB must be invalidated if you remove an entry from
//     the page table.
//
// Hint: The TA solution is implemented using page_lookup,
// 	tlb_invalidate, and page_decref.
//
void
page_remove(pde_t *pgdir, void *va)
{
	// Fill this function in
	struct PageInfo* p;
	pte_t *pte;
	if ((p = page_lookup(pgdir, va, &pte)) == NULL) {
		return;
	}
	page_decref(p);
	if (pte) {
		*pte = 0;
	}
	tlb_invalidate(pgdir, va);
}
```

##### page_insert

è¯¥å‡½æ•°çš„ä½œç”¨è·Ÿremoveç›¸åï¼Œå°†vaæ˜ å°„åˆ°å¯¹åº”çš„paä¸Šï¼Œå¢åŠ pageinfoç»“æ„çš„å¼•ç”¨ï¼Œå¯ä»¥å¾ˆç®€å•åœ°å®ç°ï¼Œä½†è¿™ä¸ªæœ‰ä¸ªCorner-case hintçš„åœ°æ–¹ï¼Œè®²çš„æ˜¯å¦‚æœåŒä¸€ä¸ªè™šæ‹Ÿåœ°å€æ˜ å°„åˆ°åŒä¸€ä¸ªç‰©ç†åœ°å€è¯¥æ€ä¹ˆåŠï¼š

1. é¦–å…ˆï¼Œåˆ¤æ–­vaå¯¹åº”çš„PTEçš„pte_pä½æ˜¯å¦æœ‰æ•ˆï¼Œæœ‰æ•ˆçš„è¯è¯´æ˜å·²ç»æ˜ å°„è¿‡äº†ï¼›
2. ä¸ºäº†ä¿æŒå·²ç»å†™å¥½çš„ä»£ç çš„ç»“æ„æ€§ï¼Œåªéœ€è¦å°†æ˜ å°„è¿‡çš„å†…å®¹åˆ äº†ï¼Œå†æ˜ å°„ä¸€éå°±è¡Œäº†ã€‚

```c
// Map the physical page 'pp' at virtual address 'va'.
// The permissions (the low 12 bits) of the page table entry
// should be set to 'perm|PTE_P'.
//
// Requirements
//   - If there is already a page mapped at 'va', it should be page_remove()d.
//   - If necessary, on demand, a page table should be allocated and inserted
//     into 'pgdir'.
//   - pp->pp_ref should be incremented if the insertion succeeds.
//   - The TLB must be invalidated if a page was formerly present at 'va'.
//
// Corner-case hint: Make sure to consider what happens when the same
// pp is re-inserted at the same virtual address in the same pgdir.
// However, try not to distinguish this case in your code, as this
// frequently leads to subtle bugs; there's an elegant way to handle
// everything in one code path.
//
// RETURNS:
//   0 on success
//   -E_NO_MEM, if page table couldn't be allocated
//
// Hint: The TA solution is implemented using pgdir_walk, page_remove,
// and page2pa.
//
int
page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
{
	// Fill this function in
	pte_t* pte;
	if ((pte = pgdir_walk(pgdir, va, 1)) == NULL) {
		return -E_NO_MEM; 	
	}
	pp->pp_ref++;
// é‡å¤æ˜ å°„çš„è¯ï¼Œåªéœ€è¦å°†ä¹‹å‰çš„è§£é™¤æ˜ å°„ï¼Œç„¶åå†æ˜ å°„ä¸€é
	if (*pte & PTE_P) {
		page_remove(pgdir, va);
	}
	*pte = page2pa(pp) | perm  | PTE_P; 
	return 0;
}
```

OKï¼Œç›®å‰å¾—åˆ†40åˆ†ã€‚

```
  Physical page allocator: OK 
  Page management: OK 
  ...
  Score: 40/70
```

## 3 Kernel Address Space

JOSå°†å†…å­˜åˆ†ä¸ºäº†ä¸¤éƒ¨åˆ†ï¼Œä¸€éƒ¨åˆ†æ˜¯ç”¨æˆ·ç©ºé—´ï¼Œè¿è¡Œåœ¨è™šæ‹Ÿçš„ä½åœ°å€ï¼Œå¦ä¸€éƒ¨åˆ†æ˜¯å†…æ ¸ç©ºé—´ï¼Œè¿è¡Œåœ¨äº†é«˜è™šæ‹Ÿåœ°å€ç©ºé—´ï¼Œåˆ†å‰²çº¿æ˜¯ULIMï¼Œä¸ºäº†ä¿æŠ¤å†…æ ¸çš„ä»£ç å’Œæ•°æ®ï¼Œéœ€è¦åœ¨é¡µä¸­å¢åŠ æƒé™é™åˆ¶ï¼Œä½¿å¾—ç”¨æˆ·ç©ºé—´çš„ä»£ç åªèƒ½è®¿é—®ç”¨æˆ·ç©ºé—´çš„å†…å­˜ï¼Œè¿™æ ·ç”¨æˆ·çš„ä»£ç äº§ç”Ÿçš„bugä¸ä¼šä¼¤å®³åˆ°å†…æ ¸ç©ºé—´

åœ¨[UTOP, ULIM)çš„èŒƒå›´å†…ï¼Œç”¨æˆ·ä»£ç å’Œå†…æ ¸ä»£ç éƒ½æ˜¯å¯ä»¥è®¿é—®çš„ï¼Œä½†æ˜¯éƒ½ä¸å¯ä»¥å†™ã€‚è¿™éƒ¨åˆ†ç©ºé—´çš„è®¾ç«‹ä¸»è¦æ˜¯ä¸ºäº†èƒ½è®©ç”¨æˆ·è¯»å–ä¸€äº›å†…æ ¸ä¸­çš„æ•°æ®ç»“æ„ã€‚

#### Exercise 5.

##### mem_init

è¿™ä¸ªå°±å¾ˆç®€å•äº†ï¼Œæ„æ€å°±æ˜¯è®©æˆ‘ä»¬åšæ˜ å°„ï¼Œå‡½æ•°ä¸Šé¢å·²ç»å®ç°äº†ï¼Œå‚è€ƒmemlayout.hä¸­çš„å›¾

```
/*
 * Virtual memory map:                                Permissions
 *                                                    kernel/user
 *
 *    4 Gig -------->  +------------------------------+
 *                     |                              | RW/--
 *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *                     :              .               :
 *                     :              .               :
 *                     :              .               :
 *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--
 *                     |                              | RW/--
 *                     |   Remapped Physical Memory   | RW/--
 *                     |                              | RW/--
 *    KERNBASE, ---->  +------------------------------+ 0xf0000000      --+
 *    KSTACKTOP        |     CPU0's Kernel Stack      | RW/--  KSTKSIZE   |
 *                     | - - - - - - - - - - - - - - -|                   |
 *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |
 *                     +------------------------------+                   |
 *                     |     CPU1's Kernel Stack      | RW/--  KSTKSIZE   |
 *                     | - - - - - - - - - - - - - - -|                 PTSIZE
 *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |
 *                     +------------------------------+                   |
 *                     :              .               :                   |
 *                     :              .               :                   |
 *    MMIOLIM ------>  +------------------------------+ 0xefc00000      --+
 *                     |       Memory-mapped I/O      | RW/--  PTSIZE
 * ULIM, MMIOBASE -->  +------------------------------+ 0xef800000
 *                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE
 *    UVPT      ---->  +------------------------------+ 0xef400000
 *                     |          RO PAGES            | R-/R-  PTSIZE
 *    UPAGES    ---->  +------------------------------+ 0xef000000
 *                     |           RO ENVS            | R-/R-  PTSIZE
 * UTOP,UENVS ------>  +------------------------------+ 0xeec00000
 * UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE
 *                     +------------------------------+ 0xeebff000
 *                     |       Empty Memory (*)       | --/--  PGSIZE
 *    USTACKTOP  --->  +------------------------------+ 0xeebfe000
 *                     |      Normal User Stack       | RW/RW  PGSIZE
 *                     +------------------------------+ 0xeebfd000
 *                     |                              |
 *                     |                              |
 *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *                     .                              .
 *                     .                              .
 *                     .                              .
 *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
 *                     |     Program Data & Heap      |
 *    UTEXT -------->  +------------------------------+ 0x00800000
 *    PFTEMP ------->  |       Empty Memory (*)       |        PTSIZE
 *                     |                              |
 *    UTEMP -------->  +------------------------------+ 0x00400000      --+
 *                     |       Empty Memory (*)       |                   |
 *                     | - - - - - - - - - - - - - - -|                   |
 *                     |  User STAB Data (optional)   |                 PTSIZE
 *    USTABDATA ---->  +------------------------------+ 0x00200000        |
 *                     |       Empty Memory (*)       |                   |
 *    0 ------------>  +------------------------------+                 --+
 *
 * (*) Note: The kernel ensures that "Invalid Memory" is *never* mapped.
 *     "Empty Memory" is normally unmapped, but user programs may map pages
 *     there if desired.  JOS user programs map pages temporarily at UTEMP.
```

å†…æ ¸é»˜è®¤æœ‰è¯»æƒé™ï¼ŒPTE_W è¡¨ç¤ºå†…æ ¸æœ‰å†™æƒé™ã€‚

ç”¨æˆ·è¦ç”¨PTE_Uæƒé™ä½è¡¨ç¤ºæœ‰è¯»æƒé™ï¼Œ| PTE_W è¡¨ç¤ºæœ‰å†™æƒé™ã€‚

```C
void
mem_init(void)
{
	//////////////////////////////////////////////////////////////////////
	// Map 'pages' read-only by the user at linear address UPAGES
	// Permissions:
	//    - the new image at UPAGES -- kernel R, user R
	//      (ie. perm = PTE_U | PTE_P)
	//    - pages itself -- kernel RW, user NONE
	// Your code goes here:
   	boot_map_region(kern_pgdir, 
                    UPAGES, 
                    PTSIZE,
                    PADDR(pages), 
                    (PTE_U));
               
	//////////////////////////////////////////////////////////////////////
	// Use the physical memory that 'bootstack' refers to as the kernel
	// stack.  The kernel stack grows down from virtual address KSTACKTOP.
	// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)
	// to be the kernel stack, but break this into two pieces:
	//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory
	//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if
	//       the kernel overflows its stack, it will fault rather than
	//       overwrite memory.  Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	// Your code goes here:
	boot_map_region(kern_pgdir, KSTACKTOP - KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);
	
	//////////////////////////////////////////////////////////////////////
	// Map all of physical memory at KERNBASE.
	// Ie.  the VA range [KERNBASE, 2^32) should map to
	//      the PA range [0, 2^32 - KERNBASE)
	// We might not have 2^32 - KERNBASE bytes of physical memory, but
	// we just set up the mapping anyway.
	// Permissions: kernel RW, user NONE
	// Your code goes here:
	boot_map_region(kern_pgdir, KERNBASE, 0xffffffff- KERNBASE, 0, PTE_W);
}
```

OKï¼Œç›®å‰å³å¯å¾—æ»¡åˆ†ï¼š

<div align=center>{{< image src="assets/score.png" caption="score" >}}</div>

## 4 Challenge

ç›®å‰æ²¡åšã€‚ğŸ˜…ğŸ˜…

å¯å‚è€ƒ [Pimsçš„åšå®¢](https://phimos.github.io/2020/03/30/6828-lab2/)ï¼Œè¿™å“¥ä»¬å†™äº†ä¸¤ä¸ªChallengeã€‚

----

{{<admonition tip "å‚è€ƒèµ„æ–™"  >}}

[xv6 ä¸­æ–‡æ–‡æ¡£ â€” MIT 6.828 (xv6-chinese.readthedocs.io)](https://xv6-chinese.readthedocs.io/zh/latest/index.html)

[JOSçš„ç‰©ç†é¡µè¡¨åˆ†é…å®ç°](http://lzz5235.github.io/2014/03/04/jos.html)

{{< /admonition >}}


